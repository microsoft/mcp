parameters:
- name: ContainerRegistry
  type: string
- name: DeploymentEnvironment
  type: string
- name: ServerName
  type: string
- name: DependsOn
  type: object

jobs:
- deployment: PublishACR
  displayName: "Publish Docker Images to ACR"
  condition: and(succeeded(), ne(variables['Skip.PublishPackage'], 'true')))
  dependsOn: ${{ parameters.DependsOn }}
  timeoutInMinutes: 120
  templateContext:
    type: releaseJob
    isProduction: true
    inputs:
    - input: pipelineArtifact
      artifactName: docker_output
      targetPath: $(Pipeline.Workspace)/docker_output
    - input: pipelineArtifact
      artifactName: build_info
      targetPath: $(Pipeline.Workspace)/build_info
  environment: package-publish
  pool:
    name: azsdk-pool
    image: ubuntu-24.04
    os: linux
  strategy:
    runOnce:
      deploy:
        steps:
        - task: AzureCLI@2
          displayName: Login to ${{ parameters.ContainerRegistry }}
          inputs:
            azureSubscription: "Azure SDK Engineering System"
            scriptType: pscore
            scriptLocation: inlineScript
            inlineScript: |
              az acr login --name ${{ parameters.ContainerRegistry }}

        - pwsh: |
            $buildInfoPath = "$(Pipeline.Workspace)/build_info/build_info.json"
            $buildInfo = Get-Content -Raw -Path $buildInfoPath | ConvertFrom-Json

            $serverName = '${{ parameters.ServerName }}'
            $server = $buildInfo.servers | Where-Object { $_.name -eq $serverName } | Select-Object -First 1
            if (-not $server) {
              Write-Error "Server '$serverName' not found in build info."
              exit 1
            }

            $version = $server.version
            $cliName = $server.cliName
            $dockerImageName = $server.dockerImageName

            Write-Host "##vso[task.setvariable variable=DockerImageVersion;isOutput=true]$version"
            Write-Host "##vso[task.setvariable variable=CliName;isOutput=true]$cliName"
            Write-Host "##vso[task.setvariable variable=DockerImageName;isOutput=true]$dockerImageName"
          name: SetReleaseVariables

        - script: |
            set -euo pipefail
            
            # Load image from tar
            echo "Loading image tar for ${{ parameters.ServerName }}"
            LOADED_IMAGE=$(docker load -i $(Pipeline.Workspace)/docker_output/$(SetReleaseVariables.CliName)-image.tar | grep -oP 'Loaded image: \K.*')
            echo "Loaded image: $LOADED_IMAGE"

            # Verify the loaded image exists
            docker image inspect "$LOADED_IMAGE" >/dev/null 2>&1 || { 
              echo "ERROR: Loaded image $LOADED_IMAGE not found after load"; 
              exit 1; 
            }

            # Prepare tags
            BASE_REPO="${{ parameters.ContainerRegistry }}.azurecr.io/${{ parameters.DeploymentEnvironment }}/$(SetReleaseVariables.DockerImageName)"
            VERSIONED_TAG="$BASE_REPO:$(SetReleaseVariables.DockerImageVersion)"
            LATEST_TAG="$BASE_REPO:latest"
            
            echo "Tagging $LOADED_IMAGE as:"
            echo "  Versioned tag: $VERSIONED_TAG"
            echo "  Latest tag:    $LATEST_TAG"
            
            # Tag the images
            docker tag "$LOADED_IMAGE" "$VERSIONED_TAG"
            docker tag "$LOADED_IMAGE" "$LATEST_TAG"
            
            # Verify tags exist before pushing
            docker image inspect "$VERSIONED_TAG" >/dev/null 2>&1 || { 
              echo "ERROR: Versioned tag $VERSIONED_TAG not found after tagging"; 
              exit 1; 
            }
            docker image inspect "$LATEST_TAG" >/dev/null 2>&1 || { 
              echo "ERROR: Latest tag $LATEST_TAG not found after tagging"; 
              exit 1; 
            }
            
            # Push both tags
            echo "Pushing versioned tag..."; docker push "$VERSIONED_TAG"
            echo "Pushing latest tag...";   docker push "$LATEST_TAG"
            echo "Publish complete for ${{ parameters.ServerName }}"
          displayName: Load, tag, and push image
